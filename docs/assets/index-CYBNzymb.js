(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&o(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(s){if(s.ep)return;s.ep=!0;const r=n(s);fetch(s.href,r)}})();class on{constructor(){this.rows=6,this.cols=7,this.board=[],this.currentPlayer=1,this.winner=null,this.reset()}reset(){this.board=Array(this.rows).fill(null).map(()=>Array(this.cols).fill(0)),this.currentPlayer=1,this.winner=null}dropPiece(t){if(this.winner||t<0||t>=this.cols)return null;for(let n=this.rows-1;n>=0;n--)if(this.board[n][t]===0)return this.board[n][t]=this.currentPlayer,this.checkWin(n,t)?this.winner=this.currentPlayer:this.currentPlayer=this.currentPlayer===1?2:1,{row:n,col:t,player:this.board[n][t]};return null}checkWin(t,n){const o=this.board[t][n],s=[[0,1],[1,0],[1,1],[1,-1]];for(const[r,i]of s){let y=1;for(let l=1;l<4;l++){const p=t+r*l,u=n+i*l;if(p<0||p>=this.rows||u<0||u>=this.cols||this.board[p][u]!==o)break;y++}for(let l=1;l<4;l++){const p=t-r*l,u=n-i*l;if(p<0||p>=this.rows||u<0||u>=this.cols||this.board[p][u]!==o)break;y++}if(y>=4)return!0}return!1}}const vt={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:W,n:ve,Gx:rn,Gy:an,b:At}=vt,H=32,ge=64,je={publicKey:H+1,publicKeyUncompressed:ge+1,seed:H+H/2},cn=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},x=(e="")=>{const t=new Error(e);throw cn(t,x),t},ln=e=>typeof e=="bigint",fn=e=>typeof e=="string",dn=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",G=(e,t,n="")=>{const o=dn(e),s=e?.length,r=t!==void 0;if(!o||r&&s!==t){const i=n&&`"${n}" `,y=r?` of length ${t}`:"",l=o?`length=${s}`:`type=${typeof e}`;x(i+"expected Uint8Array"+y+", got "+l)}return e},be=e=>new Uint8Array(e),Pt=(e,t)=>e.toString(16).padStart(t,"0"),St=e=>Array.from(G(e)).map(t=>Pt(t,2)).join(""),q={_0:48,_9:57,A:65,F:70,a:97,f:102},st=e=>{if(e>=q._0&&e<=q._9)return e-q._0;if(e>=q.A&&e<=q.F)return e-(q.A-10);if(e>=q.a&&e<=q.f)return e-(q.a-10)},Tt=e=>{const t="hex invalid";if(!fn(e))return x(t);const n=e.length,o=n/2;if(n%2)return x(t);const s=be(o);for(let r=0,i=0;r<o;r++,i+=2){const y=st(e.charCodeAt(i)),l=st(e.charCodeAt(i+1));if(y===void 0||l===void 0)return x(t);s[r]=y*16+l}return s},xt=()=>globalThis?.crypto,ot=()=>xt()?.subtle??x("crypto.subtle must be defined, consider polyfill"),fe=(...e)=>{const t=be(e.reduce((o,s)=>o+G(s).length,0));let n=0;return e.forEach(o=>{t.set(o,n),n+=o.length}),t},ze=(e=H)=>xt().getRandomValues(be(e)),De=BigInt,ne=(e,t,n,o="bad number: out of range")=>ln(e)&&t<=e&&e<n?e:x(o),d=(e,t=W)=>{const n=e%t;return n>=0n?n:t+n},$e=e=>d(e,ve),un=(e,t)=>{(e===0n||t<=0n)&&x("no inverse n="+e+" mod="+t);let n=d(e,t),o=t,s=0n,r=1n;for(;n!==0n;){const i=o/n,y=o%n,l=s-r*i;o=n,n=y,s=r,r=l}return o===1n?d(s,t):x("no inverse")},hn=e=>{const t=Et[e];return typeof t!="function"&&x("hashes."+e+" not set"),t},Ke=e=>e instanceof N?e:x("Point expected"),Rt=e=>d(d(e*e)*e+At),rt=e=>ne(e,0n,W),Le=e=>ne(e,1n,W),yn=e=>ne(e,1n,ve),de=e=>(e&1n)===0n,Mt=e=>Uint8Array.of(e),mn=e=>Mt(de(e)?2:3),Ct=e=>{const t=Rt(Le(e));let n=1n;for(let o=t,s=(W+1n)/4n;s>0n;s>>=1n)s&1n&&(n=n*o%W),o=o*o%W;return d(n*n)===t?n:x("sqrt invalid")};class N{static BASE;static ZERO;X;Y;Z;constructor(t,n,o){this.X=rt(t),this.Y=Le(n),this.Z=rt(o),Object.freeze(this)}static CURVE(){return vt}static fromAffine(t){const{x:n,y:o}=t;return n===0n&&o===0n?ee:new N(n,o,1n)}static fromBytes(t){G(t);const{publicKey:n,publicKeyUncompressed:o}=je;let s;const r=t.length,i=t[0],y=t.subarray(1),l=_e(y,0,H);if(r===n&&(i===2||i===3)){let p=Ct(l);const u=de(p);de(De(i))!==u&&(p=d(-p)),s=new N(l,p,1n)}return r===o&&i===4&&(s=new N(l,_e(y,H,ge),1n)),s?s.assertValidity():x("bad point: not on curve")}static fromHex(t){return N.fromBytes(Tt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){const{X:n,Y:o,Z:s}=this,{X:r,Y:i,Z:y}=Ke(t),l=d(n*y),p=d(r*s),u=d(o*y),c=d(i*s);return l===p&&u===c}is0(){return this.equals(ee)}negate(){return new N(this.X,d(-this.Y),this.Z)}double(){return this.add(this)}add(t){const{X:n,Y:o,Z:s}=this,{X:r,Y:i,Z:y}=Ke(t),l=0n,p=At;let u=0n,c=0n,f=0n;const b=d(p*3n);let v=d(n*r),S=d(o*i),R=d(s*y),D=d(n+o),M=d(r+i);D=d(D*M),M=d(v+S),D=d(D-M),M=d(n+s);let I=d(r+y);return M=d(M*I),I=d(v+R),M=d(M-I),I=d(o+s),u=d(i+y),I=d(I*u),u=d(S+R),I=d(I-u),f=d(l*M),u=d(b*R),f=d(u+f),u=d(S-f),f=d(S+f),c=d(u*f),S=d(v+v),S=d(S+v),R=d(l*R),M=d(b*M),S=d(S+R),R=d(v-R),R=d(l*R),M=d(M+R),v=d(S*M),c=d(c+v),v=d(I*M),u=d(D*u),u=d(u-v),v=d(D*S),f=d(I*f),f=d(f+v),new N(u,c,f)}subtract(t){return this.add(Ke(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return ee;if(yn(t),t===1n)return this;if(this.equals(se))return Rn(t).p;let o=ee,s=se;for(let r=this;t>0n;r=r.double(),t>>=1n)t&1n?o=o.add(r):n&&(s=s.add(r));return o}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){const{X:t,Y:n,Z:o}=this;if(this.equals(ee))return{x:0n,y:0n};if(o===1n)return{x:t,y:n};const s=un(o,W);return d(o*s)!==1n&&x("inverse invalid"),{x:d(t*s),y:d(n*s)}}assertValidity(){const{x:t,y:n}=this.toAffine();return Le(t),Le(n),d(n*n)===Rt(t)?this:x("bad point: not on curve")}toBytes(t=!0){const{x:n,y:o}=this.assertValidity().toAffine(),s=K(n);return t?fe(mn(o),s):fe(Mt(4),s,K(o))}toHex(t){return St(this.toBytes(t))}}const se=new N(rn,an,1n),ee=new N(0n,1n,0n);N.BASE=se;N.ZERO=ee;const pn=(e,t,n)=>se.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),oe=e=>De("0x"+(St(e)||"0")),_e=(e,t,n)=>oe(e.subarray(t,n)),gn=2n**256n,K=e=>Tt(Pt(ne(e,0n,gn),ge)),bn=e=>{const t=oe(G(e,H,"secret key"));return ne(t,1n,ve,"invalid secret key: outside of range")},at="SHA-256",Et={hmacSha256Async:async(e,t)=>{const n=ot(),o="HMAC",s=await n.importKey("raw",e,{name:o,hash:{name:at}},!1,["sign"]);return be(await n.sign(o,s,t))},hmacSha256:void 0,sha256Async:async e=>be(await ot().digest(at,e)),sha256:void 0},wn=(e=ze(je.seed))=>{G(e),(e.length<je.seed||e.length>1024)&&x("expected 40-1024b");const t=d(oe(e),ve-1n);return K(t+1n)},kn=e=>t=>{const n=wn(t);return{secretKey:n,publicKey:e(n)}},Lt=e=>Uint8Array.from("BIP0340/"+e,t=>t.charCodeAt(0)),Bt="aux",It="nonce",Ut="challenge",Fe=(e,...t)=>{const n=hn("sha256"),o=n(Lt(e));return n(fe(o,o,...t))},Ye=async(e,...t)=>{const n=Et.sha256Async,o=await n(Lt(e));return await n(fe(o,o,...t))},We=e=>{const t=bn(e),n=se.multiply(t),{x:o,y:s}=n.assertValidity().toAffine(),r=de(s)?t:$e(-t),i=K(o);return{d:r,px:i}},Qe=e=>$e(oe(e)),Ot=(...e)=>Qe(Fe(Ut,...e)),Dt=async(...e)=>Qe(await Ye(Ut,...e)),_t=e=>We(e).px,vn=kn(_t),Nt=(e,t,n)=>{const{px:o,d:s}=We(t);return{m:G(e),px:o,d:s,a:G(n,H)}},Ht=e=>{const t=Qe(e);t===0n&&x("sign failed: k is zero");const{px:n,d:o}=We(K(t));return{rx:n,k:o}},$t=(e,t,n,o)=>fe(t,K($e(e+n*o))),Gt="invalid signature produced",An=(e,t,n=ze(H))=>{const{m:o,px:s,d:r,a:i}=Nt(e,t,n),y=Fe(Bt,i),l=K(r^oe(y)),p=Fe(It,l,s,o),{rx:u,k:c}=Ht(p),f=Ot(u,s,o),b=$t(c,u,f,r);return jt(b,o,s)||x(Gt),b},Pn=async(e,t,n=ze(H))=>{const{m:o,px:s,d:r,a:i}=Nt(e,t,n),y=await Ye(Bt,i),l=K(r^oe(y)),p=await Ye(It,l,s,o),{rx:u,k:c}=Ht(p),f=await Dt(u,s,o),b=$t(c,u,f,r);return await Ft(b,o,s)||x(Gt),b},Sn=(e,t)=>e instanceof Promise?e.then(t):t(e),Kt=(e,t,n,o)=>{const s=G(e,ge,"signature"),r=G(t,void 0,"message"),i=G(n,H,"publicKey");try{const y=oe(i),l=Ct(y),p=de(l)?l:d(-l),u=new N(y,p,1n).assertValidity(),c=K(u.toAffine().x),f=_e(s,0,H);ne(f,1n,W);const b=_e(s,H,ge);ne(b,1n,ve);const v=fe(K(f),c,r);return Sn(o(v),S=>{const{x:R,y:D}=pn(u,b,$e(-S)).toAffine();return!(!de(D)||R!==f)})}catch{return!1}},jt=(e,t,n)=>Kt(e,t,n,Ot),Ft=async(e,t,n)=>Kt(e,t,n,Dt),Yt={keygen:vn,getPublicKey:_t,sign:An,verify:jt,signAsync:Pn,verifyAsync:Ft},Ne=8,Tn=256,Zt=Math.ceil(Tn/Ne)+1,Ze=2**(Ne-1),xn=()=>{const e=[];let t=se,n=t;for(let o=0;o<Zt;o++){n=t,e.push(n);for(let s=1;s<Ze;s++)n=n.add(t),e.push(n);t=n.double()}return e};let ct;const it=(e,t)=>{const n=t.negate();return e?n:t},Rn=e=>{const t=ct||(ct=xn());let n=ee,o=se;const s=2**Ne,r=s,i=De(s-1),y=De(Ne);for(let l=0;l<Zt;l++){let p=Number(e&i);e>>=y,p>Ze&&(p-=r,e+=1n);const u=l*Ze,c=u,f=u+Math.abs(p)-1,b=l%2!==0,v=p<0;p===0?o=o.add(it(b,t[c])):n=n.add(it(v,t[f]))}return e!==0n&&x("invalid wnaf"),{p:n,f:o}},{floor:qe,random:Mn,sin:Cn}=Math,we="Trystero",ke=(e,t)=>Array(e).fill().map(t),lt="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",Xe=e=>ke(e,()=>lt[qe(Mn()*lt.length)]).join(""),ie=Xe(20),te=Promise.all.bind(Promise),qt=typeof window<"u",{entries:ft,fromEntries:En,keys:Ln}=Object,V=()=>{},J=e=>new Error(`${we}: ${e}`),Bn=new TextEncoder,In=new TextDecoder,le=e=>Bn.encode(e),Be=e=>In.decode(e),Ve=e=>e.reduce((t,n)=>t+n.toString(16).padStart(2,"0"),""),Re=(...e)=>e.join("@"),Un=(e,t)=>{const n=[...e],o=()=>{const r=Cn(t++)*1e4;return r-qe(r)};let s=n.length;for(;s;){const r=qe(o()*s--);[n[s],n[r]]=[n[r],n[s]]}return n},On=(e,t,n,o)=>(e.relayUrls||Un(t,Xt(e.appId))).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||n),z=JSON.stringify,He=JSON.parse,Xt=(e,t=Number.MAX_SAFE_INTEGER)=>e.split("").reduce((n,o)=>n+o.charCodeAt(0),0)%t,dt=3333,Me={};let pe=null,Je=null;const Dn=()=>{pe||(pe=new Promise(e=>{Je=e}).finally(()=>{Je=null,pe=null}))},_n=()=>Je?.(),Nn=(e,t)=>{const n={},o=()=>{const s=new WebSocket(e);s.onclose=()=>{if(pe){pe.then(o);return}Me[e]??=dt,setTimeout(o,Me[e]),Me[e]*=2},s.onmessage=r=>t(r.data),n.socket=s,n.url=s.url,n.ready=new Promise(r=>s.onopen=()=>{r(n),Me[e]=dt}),n.send=r=>{s.readyState===1&&s.send(r)}};return o(),n},Hn=()=>{if(qt){const e=new AbortController;return addEventListener("online",_n,{signal:e.signal}),addEventListener("offline",Dn,{signal:e.signal}),()=>e.abort()}return V},et="AES-GCM",$n={},Gn=e=>btoa(String.fromCharCode.apply(null,new Uint8Array(e))),Kn=e=>{const t=atob(e);return new Uint8Array(t.length).map((n,o)=>t.charCodeAt(o)).buffer},Vt=async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,le(t))),Ce=async e=>$n[e]||=Array.from(await Vt("SHA-1",e)).map(t=>t.toString(36)).join(""),jn=async(e,t,n)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},le(`${e}:${t}:${n}`)),{name:et},!1,["encrypt","decrypt"]),Jt="$",zt=",",Fn=async(e,t)=>{const n=crypto.getRandomValues(new Uint8Array(16));return n.join(zt)+Jt+Gn(await crypto.subtle.encrypt({name:et,iv:n},await e,le(t)))},Yn=async(e,t)=>{const[n,o]=t.split(Jt);return Be(await crypto.subtle.decrypt({name:et,iv:new Uint8Array(n.split(zt))},await e,Kn(o)))},Zn=5e3,ut="icegatheringstatechange",ht="offer",qn="answer",yt=(e,{rtcConfig:t,rtcPolyfill:n,turnConfig:o})=>{const s=new(n||RTCPeerConnection)({iceServers:Xn.concat(o||[]),...t}),r={};let i=!1,y=!1,l=null;const p=c=>{c.binaryType="arraybuffer",c.bufferedAmountLowThreshold=65535,c.onmessage=f=>r.data?.(f.data),c.onopen=()=>r.connect?.(),c.onclose=()=>r.close?.(),c.onerror=f=>r.error?.(f)},u=c=>Promise.race([new Promise(f=>{const b=()=>{c.iceGatheringState==="complete"&&(c.removeEventListener(ut,b),f())};c.addEventListener(ut,b),b()}),new Promise(f=>setTimeout(f,Zn))]).then(()=>({type:c.localDescription.type,sdp:c.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(l=s.createDataChannel("data"),p(l)):s.ondatachannel=({channel:c})=>{l=c,p(c)},s.onnegotiationneeded=async()=>{try{i=!0,await s.setLocalDescription();const c=await u(s);r.signal?.(c)}catch(c){r.error?.(c)}finally{i=!1}},s.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(s.connectionState)&&r.close?.()},s.ontrack=c=>{r.track?.(c.track,c.streams[0]),r.stream?.(c.streams[0])},s.onremovestream=c=>r.stream?.(c.stream),e&&(s.canTrickleIceCandidates||s.onnegotiationneeded()),{created:Date.now(),connection:s,get channel(){return l},get isDead(){return s.connectionState==="closed"},async signal(c){if(!(l?.readyState==="open"&&!c.sdp?.includes("a=rtpmap")))try{if(c.type===ht){if(i||s.signalingState!=="stable"&&!y){if(e)return;await te([s.setLocalDescription({type:"rollback"}),s.setRemoteDescription(c)])}else await s.setRemoteDescription(c);await s.setLocalDescription();const f=await u(s);return r.signal?.(f),f}else if(c.type===qn){y=!0;try{await s.setRemoteDescription(c)}finally{y=!1}}}catch(f){r.error?.(f)}},sendData:c=>l.send(c),destroy:()=>{l?.close(),s.close(),i=!1,y=!1},setHandlers:c=>Object.assign(r,c),offerPromise:e?new Promise(c=>r.signal=f=>{f.type===ht&&c(f)}):Promise.resolve(),addStream:c=>c.getTracks().forEach(f=>s.addTrack(f,c)),removeStream:c=>s.getSenders().filter(f=>c.getTracks().includes(f.track)).forEach(f=>s.removeTrack(f)),addTrack:(c,f)=>s.addTrack(c,f),removeTrack:c=>{const f=s.getSenders().find(b=>b.track===c);f&&s.removeTrack(f)},replaceTrack:(c,f)=>{const b=s.getSenders().find(v=>v.track===c);if(b)return b.replaceTrack(f)}}},Xn=[...ke(3,(e,t)=>`stun:stun${t||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),Vn=Object.getPrototypeOf(Uint8Array),Ie=12,Wt=0,Ue=Wt+Ie,Oe=Ue+1,ye=Oe+1,me=ye+1,Q=16*2**10-me,Ee=255,mt="bufferedamountlow",ae=e=>"@_"+e,Jn=(e,t,n)=>{const o={},s={},r={},i={},y={},l={},p={},u={onPeerJoin:V,onPeerLeave:V,onPeerStream:V,onPeerTrack:V},c=(a,h)=>(a?Array.isArray(a)?a:[a]:Ln(o)).flatMap(w=>{const k=o[w];return k?h(w,k):(console.warn(`${we}: no peer with id ${w} found`),[])}),f=a=>{o[a]&&(o[a].destroy(),delete o[a],delete i[a],delete y[a],u.onPeerLeave(a),t(a))},b=a=>{if(s[a])return r[a];if(!a)throw J("action type argument is required");const h=le(a);if(h.byteLength>Ie)throw J(`action type string "${a}" (${h.byteLength}b) exceeds byte limit (${Ie}). Hint: choose a shorter name.`);const w=new Uint8Array(Ie);w.set(h);let k=0;return s[a]={onComplete:V,onProgress:V,setOnComplete:P=>s[a]={...s[a],onComplete:P},setOnProgress:P=>s[a]={...s[a],onProgress:P},send:async(P,m,g,T)=>{if(g&&typeof g!="object")throw J("action meta argument must be an object");const _=typeof P;if(_==="undefined")throw J("action data cannot be undefined");const E=_!=="string",j=P instanceof Blob,A=j||P instanceof ArrayBuffer||P instanceof Vn;if(g&&!A)throw J("action meta argument can only be used with binary data");const U=A?new Uint8Array(j?await P.arrayBuffer():P):le(E?z(P):P),$=g?le(z(g)):null,C=Math.ceil(U.byteLength/Q)+(g?1:0)||1,L=ke(C,(B,O)=>{const F=O===C-1,Y=g&&O===0,Z=new Uint8Array(me+(Y?$.byteLength:F?U.byteLength-Q*(C-(g?2:1)):Q));return Z.set(w),Z.set([k],Ue),Z.set([F|Y<<1|A<<2|E<<3],Oe),Z.set([Math.round((O+1)/C*Ee)],ye),Z.set(g?Y?$:U.subarray((O-1)*Q,O*Q):U.subarray(O*Q,(O+1)*Q),me),Z});return k=k+1&Ee,te(c(m,async(B,O)=>{const{channel:F}=O;let Y=0;for(;Y<C;){const Z=L[Y];if(F.bufferedAmount>F.bufferedAmountLowThreshold&&await new Promise(sn=>{const nt=()=>{F.removeEventListener(mt,nt),sn()};F.addEventListener(mt,nt)}),!o[B])break;O.sendData(Z),Y++,T?.(Z[ye]/Ee,B,g)}}))}},r[a]||=[s[a].send,s[a].setOnComplete,s[a].setOnProgress]},v=(a,h)=>{const w=new Uint8Array(h),k=Be(w.subarray(Wt,Ue)).replaceAll("\0",""),[P]=w.subarray(Ue,Oe),[m]=w.subarray(Oe,ye),[g]=w.subarray(ye,me),T=w.subarray(me),_=!!(m&1),E=!!(m&2),j=!!(m&4),A=!!(m&8);if(!s[k]){console.warn(`${we}: received message with unregistered type (${k})`);return}i[a]||={},i[a][k]||={};const U=i[a][k][P]||={chunks:[]};if(E?U.meta=He(Be(T)):U.chunks.push(T),s[k].onProgress(g/Ee,a,U.meta),!_)return;const $=new Uint8Array(U.chunks.reduce((C,L)=>C+L.byteLength,0));if(U.chunks.reduce((C,L)=>($.set(L,C),C+L.byteLength),0),delete i[a][k][P],j)s[k].onComplete($,a,U.meta);else{const C=Be($);s[k].onComplete(A?He(C):C,a)}},S=async()=>{await Te(""),await new Promise(a=>setTimeout(a,99)),ft(o).forEach(([a,h])=>{h.destroy(),delete o[a]}),n()},[R,D]=b(ae("ping")),[M,I]=b(ae("pong")),[Ae,Pe]=b(ae("signal")),[Se,ue]=b(ae("stream")),[re,Ge]=b(ae("track")),[Te,xe]=b(ae("leave"));return e((a,h)=>{o[h]||(o[h]=a,a.setHandlers({data:w=>v(h,w),stream:w=>{u.onPeerStream(w,h,l[h]),delete l[h]},track:(w,k)=>{u.onPeerTrack(w,k,h,p[h]),delete p[h]},signal:w=>Ae(w,h),close:()=>f(h),error:w=>{console.error(w),f(h)}}),u.onPeerJoin(h))}),D((a,h)=>M("",h)),I((a,h)=>{y[h]?.(),delete y[h]}),Pe((a,h)=>o[h]?.signal(a)),ue((a,h)=>l[h]=a),Ge((a,h)=>p[h]=a),xe((a,h)=>f(h)),qt&&addEventListener("beforeunload",S),{makeAction:b,leave:S,ping:async a=>{if(!a)throw J("ping() must be called with target peer ID");const h=Date.now();return R("",a),await new Promise(w=>y[a]=w),Date.now()-h},getPeers:()=>En(ft(o).map(([a,h])=>[a,h.connection])),addStream:(a,h,w)=>c(h,async(k,P)=>{w&&await Se(w,k),P.addStream(a)}),removeStream:(a,h)=>c(h,(w,k)=>k.removeStream(a)),addTrack:(a,h,w,k)=>c(w,async(P,m)=>{k&&await re(k,P),m.addTrack(a,h)}),removeTrack:(a,h)=>c(h,(w,k)=>k.removeTrack(a)),replaceTrack:(a,h,w,k)=>c(w,async(P,m)=>{k&&await re(k,P),m.replaceTrack(a,h)}),onPeerJoin:a=>u.onPeerJoin=a,onPeerLeave:a=>u.onPeerLeave=a,onPeerStream:a=>u.onPeerStream=a,onPeerTrack:a=>u.onPeerTrack=a}},zn=20,Wn=5333,pt=57333,Qn=({init:e,subscribe:t,announce:n})=>{const o={};let s=!1,r,i,y,l;return(p,u,c)=>{const{appId:f}=p;if(o[f]?.[u])return o[f][u];const b={},v={},S=Re(we,f,u),R=Ce(S),D=Ce(Re(S,ie)),M=jn(p.password||"",f,u),I=m=>async g=>({type:g.type,sdp:await m(M,g.sdp)}),Ae=I(Yn),Pe=I(Fn),Se=()=>yt(!0,p),ue=(m,g,T)=>{if(v[g]){v[g]!==m&&m.destroy();return}v[g]=m,P(m,g),b[g]?.forEach((_,E)=>{E!==T&&_.destroy()}),delete b[g]},re=(m,g)=>{v[g]===m&&delete v[g]},Ge=(m,g)=>{if(v[m])return;const T=b[m]?.[g];T&&(delete b[m][g],T.destroy())},Te=m=>(i.push(...ke(m,Se)),te(i.splice(0,m).map(g=>g.offerPromise.then(Pe).then(T=>({peer:g,offer:T}))))),xe=(m,g)=>c?.({error:`incorrect password (${p.password}) when decrypting ${g}`,appId:f,peerId:m,roomId:u}),a=m=>async(g,T,_)=>{const[E,j]=await te([R,D]);if(g!==E&&g!==j)return;const{peerId:A,offer:U,answer:$,peer:C}=typeof T=="string"?He(T):T;if(!(A===ie||v[A])){if(A&&!U&&!$){if(b[A]?.[m])return;const[[{peer:L,offer:B}],O]=await te([Te(1),Ce(Re(S,A))]);b[A]||=[],b[A][m]=L,setTimeout(()=>Ge(A,m),h[m]*.9),L.setHandlers({connect:()=>ue(L,A,m),close:()=>re(L,A)}),_(O,z({peerId:ie,offer:B}))}else if(U){if(b[A]?.[m]&&ie>A)return;const B=yt(!1,p);B.setHandlers({connect:()=>ue(B,A,m),close:()=>re(B,A)});let O;try{O=await Ae(U)}catch{xe(A,"offer");return}if(B.isDead)return;const[F,Y]=await te([Ce(Re(S,A)),B.signal(O)]);_(F,z({peerId:ie,answer:await Pe(Y)}))}else if($){let L;try{L=await Ae($)}catch{xe(A,"answer");return}if(C)C.setHandlers({connect:()=>ue(C,A,m),close:()=>re(C,A)}),C.signal(L);else{const B=b[A]?.[m];B&&!B.isDead&&B.signal(L)}}}};if(!p)throw J("requires a config map as the first argument");if(!f&&!p.firebaseApp)throw J("config map is missing appId field");if(!u)throw J("roomId argument required");if(!s){const m=e(p);i=ke(zn,Se),r=Array.isArray(m)?m:[m],s=!0,y=setInterval(()=>i=i.filter(g=>{const T=Date.now()-g.created<pt;return T||g.destroy(),T}),pt*1.03),l=p.manualRelayReconnection?V:Hn()}const h=r.map(()=>Wn),w=[],k=r.map(async(m,g)=>t(await m,await R,await D,a(g),Te));te([R,D]).then(([m,g])=>{const T=async(_,E)=>{const j=await n(_,m,g);typeof j=="number"&&(h[E]=j),w[E]=setTimeout(()=>T(_,E),h[E])};k.forEach(async(_,E)=>{await _,T(await r[E],E)})});let P=V;return o[f]||={},o[f][u]=Jn(m=>P=m,m=>delete v[m],()=>{delete o[f][u],w.forEach(clearTimeout),k.forEach(async m=>(await m)()),clearInterval(y),l(),s=!1})}},es=5,Qt="x",en="EVENT",{secretKey:ts,publicKey:ns}=Yt.keygen(),ss=Ve(ns),tt={},he={},os={},tn=()=>Math.floor(Date.now()/1e3),nn=e=>os[e]??=Xt(e,1e4)+2e4,gt=async(e,t)=>{const n={kind:nn(e),tags:[[Qt,e]],created_at:tn(),content:t,pubkey:ss},o=await Vt("SHA-256",z([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]));return z([en,{...n,id:Ve(o),sig:Ve(await Yt.signAsync(o,ts))}])},bt=(e,t)=>(tt[e]=t,z(["REQ",e,{kinds:[nn(t)],since:tn(),["#"+Qt]:[t]}])),wt=e=>(delete tt[e],z(["CLOSE",e])),kt=Qn({init:e=>On(e,rs,es).map(t=>{const n=Nn(t,o=>{const[s,r,i,y]=He(o);if(s!==en){const l=`${we}: relay failure from ${n.url} - `;s==="NOTICE"?console.warn(l+r):s==="OK"&&!i&&console.warn(l+y);return}he[r]?.(tt[r],i.content)});return n.ready}),subscribe:(e,t,n,o)=>{const s=Xe(64),r=Xe(64);return he[s]=he[r]=(i,y)=>o(i,y,async(l,p)=>e.send(await gt(l,p))),e.send(bt(s,t)),e.send(bt(r,n)),()=>{e.send(wt(s)),e.send(wt(r)),delete he[s],delete he[r]}},announce:async(e,t)=>e.send(await gt(t,z({peerId:ie})))}),rs=["black.nostrcity.club","ftp.halifax.rwth-aachen.de/nostr","nos.lol","nostr.cool110.xyz","nostr.data.haus","nostr.sathoarder.com","nostr.vulpem.com","relay.agorist.space","relay.binaryrobot.com","relay.damus.io","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.verified-nostr.com","yabu.me/v2"].map(e=>"wss://"+e);class as{constructor(){this.lobbyRoom=null,this.gameRoom=null,this.onMatchFoundCallback=null,this.onMoveReceivedCallback=null,this.onPeerDisconnectCallback=null,this.isHost=!1,this.peerId=null,this.matchmakingId=null}joinLobby(){const t={appId:"connect4-webrtc-game"};this.lobbyRoom=kt(t,"connect4-global-lobby"),this.matchmakingId=crypto.randomUUID();const[n,o]=this.lobbyRoom.makeAction("matchRequest"),[s,r]=this.lobbyRoom.makeAction("matchAccept");setTimeout(()=>n({type:"seeking",id:this.matchmakingId}),500),this.lobbyRoom.onPeerJoin(i=>{console.log("Peer joined lobby:",i),n({type:"seeking",id:this.matchmakingId},i)}),o((i,y)=>{if(i.type==="seeking")if(console.log(`Match request from ${y} with ID ${i.id}. My ID: ${this.matchmakingId}`),this.matchmakingId>i.id){console.log("I am Host");const l=crypto.randomUUID();s({roomId:l},y),this.joinGameRoom(l,!0),this.lobbyRoom.leave(),this.onMatchFoundCallback&&this.onMatchFoundCallback(!0)}else console.log("I am Client (waiting for accept)")}),r((i,y)=>{console.log("Received Match Accept"),this.joinGameRoom(i.roomId,!1),this.lobbyRoom.leave(),this.onMatchFoundCallback&&this.onMatchFoundCallback(!1)})}findMatch(t){this.onMatchFoundCallback=t,this.joinLobby()}joinGameRoom(t,n){this.isHost=n;const o={appId:"connect4-webrtc-game"};this.gameRoom=kt(o,t);const[s,r]=this.gameRoom.makeAction("move"),[i,y]=this.gameRoom.makeAction("restart");this.sendMoveAction=s,this.sendRestartAction=i,r((l,p)=>{this.onMoveReceivedCallback&&this.onMoveReceivedCallback(l)}),y((l,p)=>{this.onRestartReceivedCallback&&this.onRestartReceivedCallback()}),this.gameRoom.onPeerLeave(l=>{this.onPeerDisconnectCallback&&this.onPeerDisconnectCallback()})}sendMove(t){this.sendMoveAction&&this.sendMoveAction({col:t})}sendRestart(){this.sendRestartAction&&this.sendRestartAction({})}onMoveReceived(t){this.onMoveReceivedCallback=t}onRestartReceived(t){this.onRestartReceivedCallback=t}onPeerDisconnect(t){this.onPeerDisconnectCallback=t}}const X=new on,ce=new as,cs={elements:{status:document.getElementById("status"),findMatchBtn:document.getElementById("find-match-btn"),lobbyStatus:document.getElementById("lobby-status"),gameBoard:document.getElementById("game-board"),restartBtn:document.getElementById("restart-btn"),lobbyControls:document.getElementById("lobby-controls")},state:{inGame:!1,isMyTurn:!1,myPlayerId:null},init(){this.elements.findMatchBtn.addEventListener("click",()=>this.findMatch()),this.elements.restartBtn.addEventListener("click",()=>this.requestRestart()),this.renderBoard(),this.elements.status.textContent="Welcome! Find a match to play."},findMatch(){this.elements.findMatchBtn.classList.add("hidden"),this.elements.lobbyStatus.classList.remove("hidden"),this.elements.status.textContent="Searching for opponent...",ce.findMatch(e=>{this.startGame(e)})},startGame(e){this.state.inGame=!0,this.state.myPlayerId=e?1:2,this.state.isMyTurn=e,this.elements.lobbyControls.classList.add("hidden"),this.elements.gameBoard.classList.remove("hidden"),this.elements.restartBtn.classList.remove("hidden"),this.updateStatus(),ce.onMoveReceived(t=>{this.handleRemoteMove(t.col)}),ce.onRestartReceived(()=>{this.resetGame()}),ce.onPeerDisconnect(()=>{alert("Opponent disconnected!"),location.reload()})},updateStatus(){if(X.winner){X.winner===this.state.myPlayerId?this.elements.status.textContent="You Won! ðŸŽ‰":this.elements.status.textContent="You Lost ðŸ˜”";return}this.state.isMyTurn?(this.elements.status.textContent="Your Turn",this.elements.status.style.color=this.state.myPlayerId===1?"var(--player1-color)":"var(--player2-color)"):(this.elements.status.textContent="Opponent's Turn",this.elements.status.style.color="var(--text-color)")},renderBoard(){this.elements.gameBoard.innerHTML="";for(let e=0;e<X.rows;e++)for(let t=0;t<X.cols;t++){const n=document.createElement("div");n.className="cell",n.dataset.row=e,n.dataset.col=t,n.addEventListener("click",()=>this.handleCellClick(t)),this.elements.gameBoard.appendChild(n)}},handleCellClick(e){if(!this.state.inGame||!this.state.isMyTurn||X.winner)return;const t=X.dropPiece(e);t&&(this.updateBoardUI(t.row,t.col,t.player),ce.sendMove(e),this.state.isMyTurn=!1,this.updateStatus())},handleRemoteMove(e){const t=X.dropPiece(e);t&&(this.updateBoardUI(t.row,t.col,t.player),this.state.isMyTurn=!0,this.updateStatus())},updateBoardUI(e,t,n){const o=e*X.cols+t,s=this.elements.gameBoard.children[o];s&&s.classList.add(n===1?"player1":"player2")},requestRestart(){ce.sendRestart(),this.resetGame()},resetGame(){X.reset(),Array.from(this.elements.gameBoard.children).forEach(e=>{e.classList.remove("player1","player2")}),this.state.isMyTurn=this.state.myPlayerId===1,this.updateStatus()}};cs.init();
